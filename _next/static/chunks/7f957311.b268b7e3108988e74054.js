(window.webpackJsonp_N_E=window.webpackJsonp_N_E||[]).push([[7],{oAua:function(e,t,s){"use strict";const i=s("OjXq"),{ExchangeError:r,ExchangeNotAvailable:n,OnMaintenance:a,ArgumentsRequired:o,BadRequest:d,AccountSuspended:c,InvalidAddress:h,PermissionDenied:u,DDoSProtection:l,InsufficientFunds:f,InvalidNonce:m,CancelPending:p,InvalidOrder:y,OrderNotFound:g,AuthenticationError:_,RequestTimeout:w,NotSupported:b,BadSymbol:S,RateLimitExceeded:k}=s("ucJe"),{TICK_SIZE:v,TRUNCATE:O}=s("rwG2"),T=s("sbZx");e.exports=class extends i{describe(){return this.deepExtend(super.describe(),{id:"okex",name:"OKEX",countries:["CN","US"],version:"v3",rateLimit:1e3,pro:!0,has:{cancelOrder:!0,CORS:!1,createOrder:!0,fetchBalance:!0,fetchClosedOrders:!0,fetchCurrencies:!1,fetchDepositAddress:!0,fetchDeposits:!0,fetchLedger:!0,fetchMarkets:!0,fetchMyTrades:!0,fetchOHLCV:!0,fetchOpenOrders:!0,fetchOrder:!0,fetchOrderBook:!0,fetchOrders:!1,fetchOrderTrades:!0,fetchTime:!0,fetchTicker:!0,fetchTickers:!0,fetchTrades:!0,fetchTransactions:!1,fetchWithdrawals:!0,futures:!0,withdraw:!0},timeframes:{"1m":"60","3m":"180","5m":"300","15m":"900","30m":"1800","1h":"3600","2h":"7200","4h":"14400","6h":"21600","12h":"43200","1d":"86400","1w":"604800","1M":"2678400","3M":"8035200","6M":"16070400","1y":"31536000"},hostname:"okex.com",urls:{logo:"https://user-images.githubusercontent.com/1294454/32552768-0d6dd3c6-c4a6-11e7-90f8-c043b64756a7.jpg",api:{rest:"https://www.{hostname}"},www:"https://www.okex.com",doc:"https://www.okex.com/docs/en/",fees:"https://www.okex.com/pages/products/fees.html",referral:"https://www.okex.com/join/1888677",test:{rest:"https://testnet.okex.com"}},api:{general:{get:["time"]},account:{get:["wallet","sub-account","asset-valuation","wallet/{currency}","withdrawal/history","withdrawal/history/{currency}","ledger","deposit/address","deposit/history","deposit/history/{currency}","currencies","withdrawal/fee"],post:["transfer","withdrawal"]},spot:{get:["accounts","accounts/{currency}","accounts/{currency}/ledger","orders","amend_order/{instrument_id}","orders_pending","orders/{order_id}","orders/{client_oid}","trade_fee","fills","algo","instruments","instruments/{instrument_id}/book","instruments/ticker","instruments/{instrument_id}/ticker","instruments/{instrument_id}/trades","instruments/{instrument_id}/candles","instruments/{instrument_id}/history/candles"],post:["order_algo","orders","batch_orders","cancel_orders/{order_id}","cancel_orders/{client_oid}","cancel_batch_algos","cancel_batch_orders"]},margin:{get:["accounts","accounts/{instrument_id}","accounts/{instrument_id}/ledger","accounts/availability","accounts/{instrument_id}/availability","accounts/borrowed","accounts/{instrument_id}/borrowed","orders","accounts/{instrument_id}/leverage","orders/{order_id}","orders/{client_oid}","orders_pending","fills","instruments/{instrument_id}/mark_price"],post:["accounts/borrow","accounts/repayment","orders","batch_orders","cancel_orders","cancel_orders/{order_id}","cancel_orders/{client_oid}","cancel_batch_orders","accounts/{instrument_id}/leverage"]},futures:{get:["position","{instrument_id}/position","accounts","accounts/{underlying}","accounts/{underlying}/leverage","accounts/{underlying}/ledger","order_algo/{instrument_id}","orders/{instrument_id}","orders/{instrument_id}/{order_id}","orders/{instrument_id}/{client_oid}","fills","trade_fee","accounts/{instrument_id}/holds","order_algo/{instrument_id}","instruments","instruments/{instrument_id}/book","instruments/ticker","instruments/{instrument_id}/ticker","instruments/{instrument_id}/trades","instruments/{instrument_id}/candles","instruments/{instrument_id}/history/candles","instruments/{instrument_id}/index","rate","instruments/{instrument_id}/estimated_price","instruments/{instrument_id}/open_interest","instruments/{instrument_id}/price_limit","instruments/{instrument_id}/mark_price","instruments/{instrument_id}/liquidation"],post:["accounts/{underlying}/leverage","order","amend_order/{instrument_id}","orders","cancel_order/{instrument_id}/{order_id}","cancel_order/{instrument_id}/{client_oid}","cancel_batch_orders/{instrument_id}","accounts/margin_mode","close_position","cancel_all","order_algo","cancel_algos"]},swap:{get:["position","{instrument_id}/position","accounts","{instrument_id}/accounts","accounts/{instrument_id}/settings","accounts/{instrument_id}/ledger","orders/{instrument_id}","orders/{instrument_id}/{order_id}","orders/{instrument_id}/{client_oid}","fills","accounts/{instrument_id}/holds","trade_fee","order_algo/{instrument_id}","instruments","instruments/{instrument_id}/depth","instruments/ticker","instruments/{instrument_id}/ticker","instruments/{instrument_id}/trades","instruments/{instrument_id}/candles","instruments/{instrument_id}/history/candles","instruments/{instrument_id}/index","rate","instruments/{instrument_id}/open_interest","instruments/{instrument_id}/price_limit","instruments/{instrument_id}/liquidation","instruments/{instrument_id}/funding_time","instruments/{instrument_id}/mark_price","instruments/{instrument_id}/historical_funding_rate"],post:["accounts/{instrument_id}/leverage","order","amend_order/{instrument_id}","orders","cancel_order/{instrument_id}/{order_id}","cancel_order/{instrument_id}/{client_oid}","cancel_batch_orders/{instrument_id}","order_algo","cancel_algos","close_position","cancel_all","order_algo","cancel_algos"]},option:{get:["accounts","position","{underlying}/position","accounts/{underlying}","orders/{underlying}","fills/{underlying}","accounts/{underlying}/ledger","trade_fee","orders/{underlying}/{order_id}","orders/{underlying}/{client_oid}","underlying","instruments/{underlying}","instruments/{underlying}/summary","instruments/{underlying}/summary/{instrument_id}","instruments/{instrument_id}/book","instruments/{instrument_id}/trades","instruments/{instrument_id}/ticker","instruments/{instrument_id}/candles"],post:["order","orders","cancel_order/{underlying}/{order_id}","cancel_order/{underlying}/{client_oid}","cancel_batch_orders/{underlying}","amend_order/{underlying}","amend_batch_orders/{underlying}"]},index:{get:["{instrument_id}/constituents"]}},fees:{trading:{taker:.0015,maker:.001},spot:{taker:.0015,maker:.001},futures:{taker:5e-4,maker:2e-4},swap:{taker:75e-5,maker:2e-4}},requiredCredentials:{apiKey:!0,secret:!0,password:!0},exceptions:{exact:{1:r,"failure to get a peer from the ring-balancer":n,"Server is busy, please try again.":n,"An unexpected error occurred":r,"System error":r,4010:u,4001:r,4002:r,30001:_,30002:_,30003:_,30004:_,30005:m,30006:_,30007:d,30008:w,30009:r,30010:_,30011:u,30012:_,30013:_,30014:l,30015:_,30016:r,30017:r,30018:r,30019:n,30020:d,30021:d,30022:u,30023:d,30024:S,30025:d,30026:l,30027:_,30028:u,30029:c,30030:n,30031:d,30032:S,30033:d,30034:r,30035:r,30036:r,30037:n,30038:a,30044:w,32001:c,32002:u,32003:p,32004:r,32005:y,32006:y,32007:y,32008:y,32009:y,32010:r,32011:r,32012:r,32013:r,32014:r,32015:r,32016:r,32017:r,32018:r,32019:r,32020:r,32021:r,32022:r,32023:r,32024:r,32025:r,32026:r,32027:r,32028:r,32029:r,32030:y,32031:o,32038:_,32040:r,32044:r,32045:r,32046:r,32047:r,32048:y,32049:r,32050:y,32051:y,32052:r,32053:r,32057:r,32054:r,32055:y,32056:r,32058:r,32059:y,32060:y,32061:y,32062:y,32063:y,32064:r,32065:r,32066:r,32067:r,32068:r,32069:r,32070:r,32071:r,32072:r,32073:r,32074:r,32075:r,32076:r,32077:r,32078:r,32079:r,32080:r,32083:r,33001:u,33002:c,33003:f,33004:r,33005:r,33006:r,33007:r,33008:f,33009:r,33010:r,33011:r,33012:r,33013:y,33014:g,33015:y,33016:r,33017:f,33018:r,33020:r,33021:d,33022:y,33023:r,33024:y,33025:y,33026:r,33027:y,33028:y,33029:y,33034:r,33035:r,33036:r,33037:r,33038:r,33039:r,33040:r,33041:r,33042:r,33043:r,33044:r,33045:r,33046:r,33047:r,33048:r,33049:r,33050:r,33051:r,33059:d,33060:d,33061:r,33062:r,33063:r,33064:r,33065:r,33085:y,21009:r,34001:u,34002:h,34003:r,34004:r,34005:r,34006:r,34007:r,34008:f,34009:r,34010:r,34011:r,34012:r,34013:r,34014:r,34015:r,34016:u,34017:c,34018:_,34019:u,34020:u,34021:h,34022:r,34023:u,34026:k,34036:r,34037:r,34038:r,34039:r,35001:r,35002:r,35003:r,35004:r,35005:_,35008:y,35010:y,35012:y,35014:y,35015:y,35017:r,35019:y,35020:y,35021:y,35022:d,35024:d,35025:f,35026:d,35029:g,35030:y,35031:y,35032:r,35037:r,35039:f,35040:y,35044:r,35046:f,35047:f,35048:r,35049:y,35050:y,35052:f,35053:r,35055:f,35057:r,35058:r,35059:d,35060:d,35061:d,35062:y,35063:y,35064:y,35066:y,35067:y,35068:y,35069:y,35070:y,35071:y,35072:y,35073:y,35074:y,35075:y,35076:y,35077:y,35078:y,35079:y,35080:y,35081:y,35082:y,35083:y,35084:y,35085:y,35086:y,35087:y,35088:y,35089:y,35090:r,35091:r,35092:r,35093:r,35094:r,35095:d,35096:r,35097:r,35098:r,35099:r,35102:k,36001:d,36002:d,36005:r,36101:_,36102:u,36103:u,36104:u,36105:u,36106:u,36107:u,36108:f,36109:u,36201:u,36202:u,36203:y,36204:r,36205:d,36206:d,36207:y,36208:y,36209:y,36210:y,36211:y,36212:y,36213:y,36214:r,36216:g,36217:y,36218:y,36219:y,36220:y,36221:y,36222:y,36223:y,36224:y,36225:y,36226:y,36227:y,36228:y,36229:y,36230:y},broad:{}},precisionMode:v,options:{fetchOHLCV:{type:"Candles"},createMarketBuyOrderRequiresPrice:!0,fetchMarkets:["spot","futures","swap","option"],defaultType:"spot",auth:{time:"public",currencies:"private",instruments:"public",rate:"public","{instrument_id}/constituents":"public"}},commonCurrencies:{AE:"AET",BOX:"DefiBox",HOT:"Hydro Protocol",HSR:"HC",MAG:"Maggie",SBTC:"Super Bitcoin",YOYO:"YOYOW",WIN:"WinToken"}})}async fetchTime(e={}){const t=await this.generalGetTime(e);return this.parse8601(this.safeString(t,"iso"))}async fetchMarkets(e={}){const t=this.safeValue(this.options,"fetchMarkets");let s=[];for(let i=0;i<t.length;i++){const r=await this.fetchMarketsByType(t[i],e);s=this.arrayConcat(s,r)}return s}parseMarkets(e){const t=[];for(let s=0;s<e.length;s++)t.push(this.parseMarket(e[s]));return t}parseMarket(e){const t=this.safeString(e,"instrument_id");let s="spot",i=!0,r=!1,n=!1,a=!1,o=this.safeString(e,"base_currency"),d=this.safeString(e,"quote_currency");if(void 0!==this.safeNumber(e,"contract_val"))if("option_type"in e){s="option",i=!1,a=!0;const t=this.safeString(e,"underlying").split("-");o=this.safeString(t,0),d=this.safeString(t,1)}else{s="swap",i=!1,n=!0;void 0!==this.safeString(e,"alias")&&(n=!1,r=!0,s="futures",o=this.safeString(e,"underlying_index"))}const c=this.safeCurrencyCode(o),h=this.safeCurrencyCode(d),u=i?c+"/"+h:t,l=this.safeNumber2(e,"lot_size","trade_increment"),f={amount:this.safeNumber(e,"size_increment",l),price:this.safeNumber(e,"tick_size")},m=this.safeNumber2(e,"min_size","base_min_size"),p=this.safeValue2(this.fees,s,"trading",{});return this.extend(p,{id:t,symbol:u,base:c,quote:h,baseId:o,quoteId:d,info:e,type:s,spot:i,futures:r,swap:n,option:a,active:!0,precision:f,limits:{amount:{min:m,max:void 0},price:{min:f.price,max:void 0},cost:{min:f.price,max:void 0}}})}async fetchMarketsByType(e,t={}){if("option"===e){const e=await this.optionGetUnderlying(t);let s=[];for(let t=0;t<e.length;t++){const i=await this.optionGetInstrumentsUnderlying({underlying:e[t]});s=this.arrayConcat(s,i)}return this.parseMarkets(s)}if("spot"===e||"futures"===e||"swap"===e){const s=e+"GetInstruments",i=await this[s](t);return this.parseMarkets(i)}throw new b(this.id+" fetchMarketsByType does not support market type "+e)}async fetchCurrencies(e={}){const t=await this.accountGetCurrencies(e),s={};for(let i=0;i<t.length;i++){const e=t[i],r=this.safeString(e,"currency"),n=this.safeCurrencyCode(r),a=1e-8,o=this.safeString(e,"name"),d=this.safeInteger(e,"can_deposit"),c=this.safeInteger(e,"can_withdraw"),h=!(!d||!c);s[n]={id:r,code:n,info:e,type:void 0,name:o,active:h,fee:void 0,precision:a,limits:{amount:{min:void 0,max:void 0},withdraw:{min:this.safeNumber(e,"min_withdrawal"),max:void 0}}}}return s}async fetchOrderBook(e,t,s={}){await this.loadMarkets();const i=this.market(e);let r=i.type+"GetInstrumentsInstrumentId";r+="swap"===i.type?"Depth":"Book";const n={instrument_id:i.id};void 0!==t&&(n.size=t);const a=await this[r](this.extend(n,s)),o=this.parse8601(this.safeString2(a,"timestamp","time"));return this.parseOrderBook(a,e,o)}parseTicker(e,t){const s=this.parse8601(this.safeString(e,"timestamp"));let i;const r=this.safeString(e,"instrument_id");if(r in this.markets_by_id)i=(t=this.markets_by_id[r]).symbol;else if(void 0!==r){const e=r.split("-");if(2===e.length){const[t,s]=e;i=this.safeCurrencyCode(t)+"/"+this.safeCurrencyCode(s)}else i=r}void 0===i&&void 0!==t&&(i=t.symbol);const n=this.safeNumber(e,"last"),a=this.safeNumber(e,"open_24h");return{symbol:i,timestamp:s,datetime:this.iso8601(s),high:this.safeNumber(e,"high_24h"),low:this.safeNumber(e,"low_24h"),bid:this.safeNumber(e,"best_bid"),bidVolume:this.safeNumber(e,"best_bid_size"),ask:this.safeNumber(e,"best_ask"),askVolume:this.safeNumber(e,"best_ask_size"),vwap:void 0,open:a,close:n,last:n,previousClose:void 0,change:void 0,percentage:void 0,average:void 0,baseVolume:this.safeNumber(e,"base_volume_24h"),quoteVolume:this.safeNumber(e,"quote_volume_24h"),info:e}}async fetchTicker(e,t={}){await this.loadMarkets();const s=this.market(e),i=s.type+"GetInstrumentsInstrumentIdTicker",r={instrument_id:s.id},n=await this[i](this.extend(r,t));return this.parseTicker(n)}async fetchTickersByType(e,t,s={}){await this.loadMarkets();const i=e+"GetInstrumentsTicker",r=await this[i](s),n={};for(let a=0;a<r.length;a++){const e=this.parseTicker(r[a]);n[e.symbol]=e}return this.filterByArray(n,"symbol",t)}async fetchTickers(e,t={}){const s=this.safeString2(this.options,"fetchTickers","defaultType"),i=this.safeString(t,"type",s);return await this.fetchTickersByType(i,e,this.omit(t,"type"))}parseTrade(e,t){let s;const i=this.safeString(e,"instrument_id");let r,n;if(i in this.markets_by_id)s=(t=this.markets_by_id[i]).symbol,r=t.base,n=t.quote;else if(void 0!==i){const e=i.split("-");if(2===e.length){const[t,i]=e;r=this.safeCurrencyCode(t),n=this.safeCurrencyCode(i),s=r+"/"+n}else s=i}void 0===s&&void 0!==t&&(s=t.symbol,r=t.base,n=t.quote);const a=this.parse8601(this.safeString2(e,"timestamp","created_at")),o=this.safeString(e,"price");let d=this.safeString2(e,"size","qty");d=this.safeString(e,"order_qty",d);const c=this.parseNumber(o),h=this.parseNumber(d),u=this.parseNumber(T.stringMul(o,d));let l=this.safeString2(e,"exec_type","liquidity");"M"===l?l="maker":"T"===l&&(l="taker");const f=this.safeString(e,"side"),m=this.safeNumber(e,"fee");let p;if(void 0!==m){p={cost:-m,currency:"buy"===f?r:n}}const y=this.safeString(e,"order_id");return{info:e,timestamp:a,datetime:this.iso8601(a),symbol:s,id:this.safeString2(e,"trade_id","ledger_id"),order:y,type:void 0,takerOrMaker:l,side:f,price:c,amount:h,cost:u,fee:p}}async fetchTrades(e,t,s,i={}){await this.loadMarkets();const r=this.market(e),n=r.type+"GetInstrumentsInstrumentIdTrades";(void 0===s||s>100)&&(s=100);const a={instrument_id:r.id,limit:s},o=await this[n](this.extend(a,i));return this.parseTrades(o,r,t,s)}parseOHLCV(e,t){if(Array.isArray(e)){const t=e.length>6?6:5;let s=this.safeValue(e,0);return"string"===typeof s&&(s=this.parse8601(s)),[s,this.safeNumber(e,1),this.safeNumber(e,2),this.safeNumber(e,3),this.safeNumber(e,4),this.safeNumber(e,t)]}return[this.parse8601(this.safeString(e,"time")),this.safeNumber(e,"open"),this.safeNumber(e,"high"),this.safeNumber(e,"low"),this.safeNumber(e,"close"),this.safeNumber(e,"volume")]}async fetchOHLCV(e,t="1m",s,i,r={}){await this.loadMarkets();const n=this.market(e),a=this.parseTimeframe(t),o={instrument_id:n.id,granularity:this.timeframes[t]},d=this.safeValue(this.options,"fetchOHLCV",{}),c=this.safeString(d,"type","Candles"),h=this.safeString(r,"type",c);r=this.omit(r,"type");const u=n.type+"GetInstrumentsInstrumentId"+h;if("Candles"===h){if(void 0!==s)void 0!==i&&(o.end=this.iso8601(this.sum(s,i*a*1e3))),o.start=this.iso8601(s);else if(void 0!==i){const e=this.milliseconds();o.start=this.iso8601(e-i*a*1e3),o.end=this.iso8601(e)}}else if("HistoryCandles"===h){if(n.option)throw new b(this.id+" fetchOHLCV does not have "+h+" for "+n.type+" markets");if(void 0!==s)void 0===i&&(i=300),o.start=this.iso8601(this.sum(s,i*a*1e3)),o.end=this.iso8601(s);else if(void 0!==i){const e=this.milliseconds();o.end=this.iso8601(e-i*a*1e3),o.start=this.iso8601(e)}}const l=await this[u](this.extend(o,r));return this.parseOHLCVs(l,n,t,s,i)}parseAccountBalance(e){const t={info:e,timestamp:void 0,datetime:void 0};for(let s=0;s<e.length;s++){const i=e[s],r=this.safeString(i,"currency"),n=this.safeCurrencyCode(r),a=this.account();a.total=this.safeNumber(i,"balance"),a.used=this.safeNumber(i,"hold"),a.free=this.safeNumber(i,"available"),t[n]=a}return this.parseBalance(t)}parseMarginBalance(e){const t={info:e,timestamp:void 0,datetime:void 0};for(let s=0;s<e.length;s++){const i=e[s],r=this.safeString(i,"instrument_id"),n=this.safeValue(this.markets_by_id,r);let a;if(void 0===n){const[e,t]=r.split("-");a=this.safeCurrencyCode(e)+"/"+this.safeCurrencyCode(t)}else a=n.symbol;const o=this.omit(i,["instrument_id","liquidation_price","product_id","risk_rate","margin_ratio","maint_margin_ratio","tiers"]),d=Object.keys(o),c={};for(let e=0;e<d.length;e++){const t=d[e],s=i[t];if(!(t.indexOf(":")>=0))throw new b(this.id+" margin balance response format has changed!");{const e=t.split(":")[1],i=this.safeCurrencyCode(e),r=this.account();r.total=this.safeNumber(s,"balance"),r.used=this.safeNumber(s,"hold"),r.free=this.safeNumber(s,"available"),c[i]=r}}t[a]=this.parseBalance(c)}return t}parseFuturesBalance(e){const t={info:e,timestamp:void 0,datetime:void 0},s=this.safeValue(e,"info",{}),i=Object.keys(s);for(let r=0;r<i.length;r++){const e=i[r],n=this.safeCurrencyCode(e),a=this.safeValue(s,e,{}),o=this.account(),d=this.safeNumber(a,"total_avail_balance");if("fixed"===this.safeString(a,"margin_mode")){const e=this.safeValue(a,"contracts",[]);let t=d;for(let s=0;s<e.length;s++){const i=e[s],r=this.safeNumber(i,"fixed_balance"),n=this.safeNumber(i,"realized_pnl"),a=this.safeNumber(i,"margin_frozen"),o=this.safeNumber(i,"margin_for_unfilled"),d=this.sum(r,n)-a-o;t=this.sum(t,d)}o.free=t}else{const e=this.safeNumber(a,"realized_pnl"),t=this.safeNumber(a,"unrealized_pnl"),s=this.safeNumber(a,"margin_frozen"),i=this.safeNumber(a,"margin_for_unfilled");o.free=this.sum(d,e,t)-s-i}o.total=this.safeNumber(a,"equity"),t[n]=o}return this.parseBalance(t)}parseSwapBalance(e){const t={info:e};let s;const i=this.safeValue(e,"info",[]);for(let r=0;r<i.length;r++){const e=i[r],n=this.safeString(e,"instrument_id");let a=n;n in this.markets_by_id&&(a=this.markets_by_id[n].symbol);const o=this.parse8601(this.safeString(e,"timestamp"));s=void 0===s?o:Math.max(s,o);const d=this.account();d.total=this.safeNumber(e,"equity"),d.free=this.safeNumber(e,"total_avail_balance"),t[a]=d}return t.timestamp=s,t.datetime=this.iso8601(s),this.parseBalance(t)}async fetchBalance(e={}){const t=this.safeString2(this.options,"fetchBalance","defaultType"),s=this.safeString(e,"type",t);if(void 0===s)throw new o(this.id+" fetchBalance() requires a type parameter (one of 'account', 'spot', 'margin', 'futures', 'swap')");await this.loadMarkets();const i=s+"Get"+("account"===s?"Wallet":"Accounts"),r=this.omit(e,"type"),n=await this[i](r);return this.parseBalanceByType(s,n)}parseBalanceByType(e,t){if("account"===e||"spot"===e)return this.parseAccountBalance(t);if("margin"===e)return this.parseMarginBalance(t);if("futures"===e)return this.parseFuturesBalance(t);if("swap"===e)return this.parseSwapBalance(t);throw new b(this.id+" fetchBalance does not support the '"+e+"' type (the type must be one of 'account', 'spot', 'margin', 'futures', 'swap')")}async createOrder(e,t,s,i,r,n={}){await this.loadMarkets();const a=this.market(e);let o={instrument_id:a.id};const d=this.safeString2(n,"client_oid","clientOrderId");let c;if(void 0!==d&&(o.client_oid=d,n=this.omit(n,["client_oid","clientOrderId"])),a.futures||a.swap){const s=a.futures?this.numberToString(i):this.amountToPrecision(e,i);o=this.extend(o,{type:t,size:s});const d=this.safeString(n,"order_type");"market"===t||"4"===d?o.order_type="4":o.price=this.priceToPrecision(e,r),a.futures&&(o.leverage="10"),c=a.type+"PostOrder"}else{const d=this.safeString(n,"margin_trading","1");if(o=this.extend(o,{side:s,type:t,margin_trading:d}),"limit"===t)o.price=this.priceToPrecision(e,r),o.size=this.amountToPrecision(e,i);else if("market"===t)if("buy"===s){let e=this.safeNumber(n,"notional");if(this.safeValue(this.options,"createMarketBuyOrderRequiresPrice",!0)){if(void 0!==r)void 0===e&&(e=i*r);else if(void 0===e)throw new y(this.id+" createOrder() requires the price argument with market buy orders to calculate total order cost (amount to spend), where cost = amount * price. Supply a price argument to createOrder() call if you want the cost to be calculated for you from price and amount, or, alternatively, add .options['createMarketBuyOrderRequiresPrice'] = false and supply the total cost value in the 'amount' argument or in the 'notional' extra parameter (the exchange-specific behaviour)")}else e=void 0===e?i:e;const t=a.precision.price;o.notional=this.decimalToPrecision(e,O,t,this.precisionMode)}else o.size=this.amountToPrecision(e,i);c="2"===d?"marginPostOrders":"spotPostOrders"}const h=await this[c](this.extend(o,n)),u=this.parseOrder(h,a);return this.extend(u,{type:t,side:s})}async cancelOrder(e,t,s={}){if(void 0===t)throw new o(this.id+" cancelOrder() requires a symbol argument");await this.loadMarkets();const i=this.market(t);let r;if(i.futures||i.swap)r=i.type;else{const e=this.safeString2(this.options,"cancelOrder","defaultType",i.type);r=this.safeString(s,"type",e)}if(void 0===r)throw new o(this.id+" cancelOrder() requires a type parameter (one of 'spot', 'margin', 'futures', 'swap').");let n=r+"PostCancelOrder";const a={instrument_id:i.id};i.futures||i.swap?n+="InstrumentId":n+="s";const d=this.safeString2(s,"client_oid","clientOrderId");void 0!==d?(n+="ClientOid",a.client_oid=d):(n+="OrderId",a.order_id=e);const c=this.omit(s,["type","client_oid","clientOrderId"]),h=await this[n](this.extend(a,c)),u="result"in h?h:this.safeValue(h,i.id,{});return this.parseOrder(u,i)}parseOrderStatus(e){return this.safeString({"-2":"failed","-1":"canceled",0:"open",1:"open",2:"closed",3:"open",4:"canceled"},e,e)}parseOrderSide(e){return this.safeString({1:"buy",2:"sell",3:"sell",4:"buy"},e,e)}parseOrder(e,t){const s=this.safeString(e,"order_id"),i=this.parse8601(this.safeString(e,"timestamp"));let r=this.safeString(e,"side");const n=this.safeString(e,"type");let a;"buy"!==r&&"sell"!==r&&(r=this.parseOrderSide(n));const o=this.safeString(e,"instrument_id");a=o in this.markets_by_id?(t=this.markets_by_id[o]).symbol:o,void 0!==t&&void 0===a&&(a=t.symbol);let d=this.safeNumber(e,"size");const c=this.safeNumber2(e,"filled_size","filled_qty");let h;void 0!==d&&void 0!==c&&(d=Math.max(d,c),h=Math.max(0,d-c)),"market"===n&&(h=0);let u=this.safeNumber2(e,"filled_notional","funds");const l=this.safeNumber(e,"price");let f=this.safeNumber(e,"price_avg");void 0===u?void 0!==c&&void 0!==f&&(u=f*c):void 0===f&&void 0!==c&&c>0&&(f=u/c);const m=this.parseOrderStatus(this.safeString(e,"state")),p=this.safeNumber(e,"fee");let y;if(void 0!==p){y={cost:p,currency:void 0}}let g=this.safeString(e,"client_oid");void 0!==g&&g.length<1&&(g=void 0);const _=this.safeNumber(e,"trigger_price");return{info:e,id:s,clientOrderId:g,timestamp:i,datetime:this.iso8601(i),lastTradeTimestamp:void 0,symbol:a,type:n,timeInForce:void 0,postOnly:void 0,side:r,price:l,stopPrice:_,average:f,cost:u,amount:d,filled:c,remaining:h,status:m,fee:y,trades:void 0}}async fetchOrder(e,t,s={}){if(void 0===t)throw new o(this.id+" fetchOrder() requires a symbol argument");await this.loadMarkets();const i=this.market(t),r=this.safeString2(this.options,"fetchOrder","defaultType",i.type),n=this.safeString(s,"type",r);if(void 0===n)throw new o(this.id+" fetchOrder() requires a type parameter (one of 'spot', 'margin', 'futures', 'swap').");let a=n+"GetOrders"+(i.futures||i.swap?"InstrumentId":"");const d={instrument_id:i.id},c=this.safeString(s,"client_oid");void 0!==c?(a+="ClientOid",d.client_oid=c):(a+="OrderId",d.order_id=e);const h=this.omit(s,"type"),u=await this[a](this.extend(d,h));return this.parseOrder(u)}async fetchOrdersByState(e,t,s,i,r={}){if(void 0===t)throw new o(this.id+" fetchOrdersByState() requires a symbol argument");await this.loadMarkets();const n=this.market(t);let a;if(n.futures||n.swap)a=n.type;else{const e=this.safeString2(this.options,"fetchOrder","defaultType",n.type);a=this.safeString(r,"type",e)}if(void 0===a)throw new o(this.id+" fetchOrdersByState() requires a type parameter (one of 'spot', 'margin', 'futures', 'swap').");const d={instrument_id:n.id,state:e};let c=a+"GetOrders";(n.futures||n.swap)&&(c+="InstrumentId");const h=this.omit(r,"type"),u=await this[c](this.extend(d,h));let l;if(n.swap||n.futures)l=this.safeValue(u,"order_info",[]);else{l=u;const e=u.length;if(e<1)return[];if(e>1){void 0!==this.safeValue(u[1],"before")&&(l=u[0])}}return this.parseOrders(l,n,s,i)}async fetchOpenOrders(e,t,s,i={}){return await this.fetchOrdersByState("6",e,t,s,i)}async fetchClosedOrders(e,t,s,i={}){return await this.fetchOrdersByState("7",e,t,s,i)}parseDepositAddress(e,t){const s=this.safeString(e,"address");let i=this.safeString2(e,"tag","payment_id");i=this.safeString(e,"memo",i);const r=this.safeString(e,"currency"),n=this.safeCurrencyCode(r);return this.checkAddress(s),{currency:n,address:s,tag:i,info:e}}async fetchDepositAddress(e,t={}){await this.loadMarkets();const s=e.split("-"),i={currency:this.currency(s[0]).id},r=await this.accountGetDepositAddress(this.extend(i,t)),n=this.parseDepositAddresses(r),a=this.safeValue(n,e);if(void 0===a)throw new h(this.id+" fetchDepositAddress cannot return nonexistent addresses, you should create withdrawal addresses with the exchange website first");return a}async withdraw(e,t,s,i,n={}){this.checkAddress(s),await this.loadMarkets();const a=this.currency(e);i&&(s=s+":"+i);const d=this.safeString(n,"fee");if(void 0===d)throw new o(this.id+" withdraw() requires a `fee` string parameter, network transaction fee must be \u2265 0. Withdrawals to OKCoin or OKEx are fee-free, please set '0'. Withdrawing to external digital asset address requires network transaction fee.");const c={currency:a.id,to_address:s,destination:"4",amount:this.numberToString(t),fee:d};"password"in n?c.trade_pwd=n.password:"trade_pwd"in n?c.trade_pwd=n.trade_pwd:this.password&&(c.trade_pwd=this.password);const h=this.omit(n,["fee","password","trade_pwd"]);if(!("trade_pwd"in c))throw new r(this.id+" withdraw() requires this.password set on the exchange instance or a password / trade_pwd parameter");const u=await this.accountPostWithdrawal(this.extend(c,h));return{info:u,id:this.safeString(u,"withdrawal_id")}}async fetchDeposits(e,t,s,i={}){await this.loadMarkets();const r={};let n,a="accountGetDepositHistory";void 0!==e&&(n=this.currency(e),r.currency=n.id,a+="Currency");const o=await this[a](this.extend(r,i));return this.parseTransactions(o,n,t,s,i)}async fetchWithdrawals(e,t,s,i={}){await this.loadMarkets();const r={};let n,a="accountGetWithdrawalHistory";void 0!==e&&(n=this.currency(e),r.currency=n.id,a+="Currency");const o=await this[a](this.extend(r,i));return this.parseTransactions(o,n,t,s,i)}parseTransactionStatus(e){return this.safeString({"-3":"pending","-2":"canceled","-1":"failed",0:"pending",1:"pending",2:"ok",3:"pending",4:"pending",5:"pending"},e,e)}parseTransaction(e,t){let s,i,r;const n=this.safeString(e,"withdrawal_id"),a=this.safeString(e,"from"),o=this.safeString(e,"to"),d=this.safeString(e,"tag");void 0!==n?(s="withdrawal",i=n,r=o):(i=this.safeString2(e,"payment_id","deposit_id"),s="deposit",r=o);const c=this.safeString(e,"currency"),h=this.safeCurrencyCode(c),u=this.safeNumber(e,"amount"),l=this.parseTransactionStatus(this.safeString(e,"status")),f=this.safeString(e,"txid"),m=this.parse8601(this.safeString(e,"timestamp"));let p;if("deposit"===s)p=0;else if(void 0!==c){const t=this.safeString(e,"fee");if(void 0!==t){const e=c.toLowerCase(),s=t.replace(e,"");p=parseFloat(s)}}return{info:e,id:i,currency:h,amount:u,addressFrom:a,addressTo:o,address:r,tagFrom:void 0,tagTo:d,tag:d,status:l,type:s,updated:void 0,txid:f,timestamp:m,datetime:this.iso8601(m),fee:{currency:h,cost:p}}}parseMyTrade(e,t){const s=this.safeValue(e,1),i=this.safeValue(e,0),r=this.safeString(i,"instrument_id");if(r!==this.safeString(s,"instrument_id"))throw new b(this.id+" parseMyTrade() received unrecognized response format, differing instrument_ids in one fill, the exchange API might have changed, paste your verbose output: https://github.com/ccxt/ccxt/wiki/FAQ#what-is-required-to-get-help");const n=r,a=(t=this.safeMarket(n,t)).symbol,o=t.quoteId;let d,c,h;let u;this.safeString(s,"currency")===o?(d=this.safeString(i,"side"),c=this.safeNumber(i,"size"),h=this.safeNumber(s,"size"),u=this.safeString(i,"currency")):(d=this.safeString(s,"side"),c=this.safeNumber(s,"size"),h=this.safeNumber(i,"size"),u=this.safeString(s,"currency"));const l=this.safeString(s,"trade_id"),f=this.safeNumber(s,"price"),m=this.safeNumber(i,"fee"),p=this.safeNumber(s,"fee"),y=this.safeCurrencyCode(this.safeString(i,"currency")),g=this.safeCurrencyCode(this.safeString(s,"currency"));let _,w;void 0!==m&&0!==m?void 0!==p&&0!==p?w=[{cost:-m,currency:y},{cost:-p,currency:g}]:_={cost:-m,currency:y}:_=void 0!==p&&0!==p?{cost:-p,currency:g}:{cost:0,currency:this.safeCurrencyCode(u)};const S=this.parse8601(this.safeString2(s,"timestamp","created_at"));let k=this.safeString2(s,"exec_type","liquidity");"M"===k?k="maker":"T"===k&&(k="taker");const v=this.safeString(s,"order_id"),O={info:e,timestamp:S,datetime:this.iso8601(S),symbol:a,id:l,order:v,type:void 0,takerOrMaker:k,side:d,price:f,amount:c,cost:h,fee:_};return void 0!==w&&(O.fees=w),O}parseMyTrades(e,t,s,i,r={}){const n=this.groupBy(e,"trade_id"),a=Object.keys(n),o=[];for(let c=0;c<a.length;c++){const e=n[a[c]];if(2===e.length){const t=this.parseMyTrade(e);o.push(t)}}let d;return void 0!==t&&(d=t.symbol),this.filterBySymbolSinceLimit(o,d,s,i)}async fetchMyTrades(e,t,s,i={}){if(void 0===e)throw new o(this.id+" fetchMyTrades() requires a symbol argument");await this.loadMarkets();const r=this.market(e);void 0!==s&&s>100&&(s=100);const n={instrument_id:r.id},a=this.safeString2(this.options,"fetchMyTrades","defaultType"),d=this.safeString(i,"type",a),c=this.omit(i,"type"),h=d+"GetFills",u=await this[h](this.extend(n,c));return this.parseMyTrades(u,r,t,s,i)}async fetchOrderTrades(e,t,s,i,r={}){const n={order_id:e};return await this.fetchMyTrades(t,s,i,this.extend(n,r))}async fetchPosition(e,t={}){await this.loadMarkets();const s=this.market(e);let i;const r={instrument_id:s.id},n=s.type;if("futures"===n||"swap"===n)i=n+"GetInstrumentIdPosition";else{if("option"!==n)throw new b(this.id+" fetchPosition() does not support "+n+" market "+e+", supported market types are futures, swap or option");if(void 0===this.safeString(t,"underlying"))throw new o(this.id+" fetchPosition() requires an underlying parameter for "+n+" market "+e);i=n+"GetUnderlyingPosition"}return await this[i](this.extend(r,t))}async fetchPositions(e,t={}){let s;await this.loadMarkets();const i=this.safeString2(this.options,"fetchPositions","defaultType"),r=this.safeString(t,"type",i);if("futures"===r||"swap"===r)s=r+"GetPosition";else{if("option"!==r)throw new b(this.id+" fetchPositions() does not support "+r+" markets, supported market types are futures, swap or option");if(void 0===this.safeString(t,"underlying"))throw new o(this.id+" fetchPositions() requires an underlying parameter for "+r+" markets");s=r+"GetUnderlyingPosition"}t=this.omit(t,"type");return await this[s](t)}async fetchLedger(e,t,s,i={}){await this.loadMarkets();const r=this.safeString2(this.options,"fetchLedger","defaultType"),n=this.safeString(i,"type",r),a=this.omit(i,"type"),d="account"===n?"":"Accounts";let c="";const h={};let u;if(void 0!==s&&(h.limit=s),"spot"===n){if(void 0===e)throw new o(this.id+" fetchLedger() requires a currency code argument for '"+n+"' markets");c="Currency",u=this.currency(e),h.currency=u.id}else if("futures"===n){if(void 0===e)throw new o(this.id+" fetchLedger() requires an underlying symbol for '"+n+"' markets");c="Underlying";const t=this.market(e),s=this.safeValue(t,"info",{}),i=this.safeString(s,"settlement_currency"),r=this.safeCurrencyCode(i);u=this.currency(r);const a=this.safeString(s,"underlying");h.underlying=a}else if("margin"===n||"swap"===n){if(void 0===e)throw new o(this.id+" fetchLedger() requires a code argument (a market symbol) for '"+n+"' markets");c="InstrumentId";const t=this.market(e);u=this.currency(t.base),h.instrument_id=t.id}else{if("account"!==n)throw new b(this.id+" fetchLedger does not support the '"+n+"' type (the type must be one of 'account', 'spot', 'margin', 'futures', 'swap')");void 0!==e&&(u=this.currency(e),h.currency=u.id)}const l=n+"Get"+d+c+"Ledger",f=await this[l](this.extend(h,a));if(f.length<1)return[];const m=Array.isArray(f[0]),p="margin"===n&&m?f[0]:f;if("swap"===n){const i=this.parseLedger(p);return this.filterBySymbolSinceLimit(i,e,t,s)}return this.parseLedger(p,u,t,s)}parseLedgerEntryType(e){return this.safeString({transfer:"transfer",trade:"trade",rebate:"rebate",match:"trade",fee:"fee",settlement:"trade",liquidation:"trade",funding:"fee",margin:"margin"},e,e)}parseLedgerEntry(e,t){const s=this.safeString(e,"ledger_id"),i=this.safeValue(e,"details",{}),r=this.safeString(i,"order_id"),n=this.parseLedgerEntryType(this.safeString(e,"type")),a=this.safeCurrencyCode(this.safeString(e,"currency"),t),o=this.safeNumber(e,"amount"),d=this.parse8601(this.safeString(e,"timestamp")),c={cost:this.safeNumber(e,"fee"),currency:a},h=this.safeNumber(e,"balance"),u=this.safeString(e,"instrument_id");let l;if(u in this.markets_by_id){l=this.markets_by_id[u].symbol}return{info:e,id:s,account:undefined,referenceId:r,referenceAccount:undefined,type:n,currency:a,symbol:l,amount:o,before:undefined,after:h,status:"ok",timestamp:d,datetime:this.iso8601(d),fee:c}}sign(e,t="public",s="GET",i={},r,n){const a=Array.isArray(i);let o="/api/"+t+"/"+this.version+"/";o+=a?e:this.implodeParams(e,i);const d=a?i:this.omit(i,this.extractParams(e));let c=this.implodeParams(this.urls.api.rest,{hostname:this.hostname})+o;const h=this.getPathAuthenticationType(e);if("public"===h)Object.keys(d).length&&(c+="?"+this.urlencode(d));else if("private"===h){this.checkRequiredCredentials();const e=this.iso8601(this.milliseconds());r={"OK-ACCESS-KEY":this.apiKey,"OK-ACCESS-PASSPHRASE":this.password,"OK-ACCESS-TIMESTAMP":e};let t=e+s+o;if("GET"===s){if(Object.keys(d).length){const e="?"+this.urlencode(d);c+=e,t+=e}}else(a||Object.keys(d).length)&&(t+=n=this.json(d)),r["Content-Type"]="application/json";const i=this.hmac(this.encode(t),this.encode(this.secret),"sha256","base64");r["OK-ACCESS-SIGN"]=i}return{url:c,method:s,body:n,headers:r}}getPathAuthenticationType(e){if("underlying"===e)return"public";const t=this.safeValue(this.options,"auth",{}),s=this.findBroadlyMatchedKey(t,e);return this.safeString(t,s,"private")}handleErrors(e,t,s,i,a,o,d,c,h){if(!d)return;const u=this.id+" "+o;if(503===e)throw new n(u);const l=this.safeString(d,"message"),f=this.safeString2(d,"code","error_code"),m=void 0!==l&&""!==l,p=void 0!==f&&"0"!==f;if(m&&(this.throwExactlyMatchedException(this.exceptions.exact,l,u),this.throwBroadlyMatchedException(this.exceptions.broad,l,u)),p&&this.throwExactlyMatchedException(this.exceptions.exact,f,u),p||m)throw new r(u)}}}}]);